type Market @entity {
  id: Bytes! # Address
  token: Bytes! # Collateral token address
  oracle: Oracle! # Oracle address
  payoff: Bytes # Payoff address
  marketAccounts: [MarketAccount!]! @derivedFrom(field: "market") # Accounts that have positions in this market
  #
  maker: BigInt! # Global maker position
  long: BigInt! # Global long position
  short: BigInt! # Global short position
  #
  latestPrice: BigInt! # Latest price from oracle
  latestVersion: BigInt! # Latest oracle timestamp
  currentVersion: BigInt! # Current oracle timestamp
  latestOrderId: BigInt! # Latest global order id
  currentOrderId: BigInt! # Current global order id
  #
  accumulators: [MarketAccumulator!]! @derivedFrom(field: "market") # List of market accumulators for each oracle version
}

type MarketOrder @entity {
  id: Bytes! # markeetAddress:orderId
  market: Market! # Market address
  orderId: BigInt! # Global order id
  version: BigInt! # Oracle version timestamp
  #
  maker: BigInt! # Global maker position delta
  long: BigInt! # Global long position delta
  short: BigInt! # Global short position delta
  #
  oracleVersion: OracleVersion! # Oracle version
  accountOrders: [Order!]! @derivedFrom(field: "marketOrder") # Account orders for this market order
}

type Account @entity {
  id: Bytes! # Address
  marketAccounts: [MarketAccount!]! @derivedFrom(field: "account") # Markets that this account has positions in
}

type MarketAccount @entity {
  id: Bytes! # markeetAddress:accountAddress
  market: Market! # Parent Market
  account: Account! # Parent Account
  positions: [Position!]! @derivedFrom(field: "marketAccount") # Positions in this market account. A position is defined by going from zero to non-zero and back to zero.
  maker: BigInt! # Account maker position
  long: BigInt! # Account long position
  short: BigInt! # Account short position
  #
  pendingMaker: BigInt! # v2.0.1 tracking only
  pendingLong: BigInt! # v2.0.1 tracking only
  pendingShort: BigInt! # v2.0.1 tracking only
  makerInvalidation: BigInt! # v2.0.1 tracking only
  longInvalidation: BigInt! # v2.0.1 tracking only
  shortInvalidation: BigInt! # v2.0.1 tracking only
  #
  positionNonce: BigInt! # Unique ID for each position
  latestVersion: BigInt! # Latest oracle version timestamp
  currentVersion: BigInt! # Current oracle version timestamp
  latestOrderId: BigInt! # Latest account order id
  currentOrderId: BigInt! # Current account order id
  collateral: BigInt! # Current account collateral
}

type Position @entity {
  id: Bytes! # markeetAddress:accountAddress:positionNonce
  marketAccount: MarketAccount! # Parent MarketAccount
  orders: [Order!]! @derivedFrom(field: "position") # Orders for this position
  nonce: BigInt! # Unique ID for this position
  #
  maker: BigInt! # Optimistically updated on Fulfillment
  long: BigInt! # Optimistically updated on Fulfillment
  short: BigInt! # Optimistically updated on Fulfillment
  #
  startCollateral: BigInt! # Collateral at the time of position opening
  startSize: BigInt! # Position size at the time of position opening
  #
  openSize: BigInt! # Current position size
  openNotional: BigInt! # Current position notional
  #
  accumulation: Accumulation! # Accumulation for this position
}

type Order @entity {
  id: Bytes! # markeetAddress:accountAddress:orderId
  position: Position! # Parent Position
  account: Account! # Account address (needed to query by account as position.marketAccount.account is not supported)
  market: Market! # Market address (needed to query by market as position.marketAccount.account is not supported)
  orderId: BigInt! # Account order id
  marketOrder: MarketOrder! # Parent MarketOrder
  oracleVersion: OracleVersion! # Order oracle version
  startCollateral: BigInt! # Collateral at the time of transaction
  #
  liquidation: Boolean! # If this order is a liquidation
  referrer: Bytes! # Referrer account
  liquidator: Bytes! # Liquidator account
  #
  maker: BigInt! # Maker position delta
  long: BigInt! # Long position delta
  short: BigInt! # Short position delta
  collateral: BigInt! # Collateral delta
  #
  executionPrice: BigInt! # Price for order fulfillment, or if non-requested or invalid, the oracle price at time of order creation
  #
  accumulation: Accumulation! # Accumulation for this order
  #
  transactionHashes: [Bytes!]! # Transaction hashes for this order's creation
}

type OracleVersion @entity {
  id: Bytes! # oracleAddress:Version
  subOracle: SubOracle! # Parent SubOracle which requsts and fulfills this version
  marketOrders: [MarketOrder!]! @derivedFrom(field: "oracleVersion") # Market orders for this oracle version
  orders: [Order!]! @derivedFrom(field: "oracleVersion") # Orders for this oracle version
  #
  requested: Boolean! # If this version was been requested (position changes request a new version)
  timestamp: BigInt! # Timestamp of this version
  valid: Boolean! # If this version is valid
  price: BigInt! # Price for this version
  #
  requestTransactionHash: Bytes # Transaction hash that requested this version
  fulfillTransactionHash: Bytes # Transaction hash that fulfilled this version
}

type Oracle @entity {
  id: Bytes! # Address
  markets: [Market!]! @derivedFrom(field: "oracle") # Markets that use this oracle
  subOracle: SubOracle! # SubOracle that requests and fulfills this oracle
}

type SubOracle @entity {
  id: Bytes! # Address
  oracle: Oracle! # Parent Oracle
  versions: [OracleVersion!]! @derivedFrom(field: "subOracle") # Oracle versions for this sub oracle
}

# Tracking value to provide pnl breakdowns. This is a cumulative value that is updated on each oracle version. To find the pnl for a given time period, subtract the previous version's value from the current version's value and multiply by the position.
type MarketAccumulator @entity(immutable: true) {
  id: Bytes! # market:version
  market: Market! # Parent Market
  version: BigInt! # Oracle version timestamp
  pnlMaker: BigInt!
  pnlLong: BigInt!
  pnlShort: BigInt!
  fundingMaker: BigInt!
  fundingLong: BigInt!
  fundingShort: BigInt!
  interestMaker: BigInt!
  interestLong: BigInt!
  interestShort: BigInt!
  positionFeeMaker: BigInt!
  exposureMaker: BigInt!
  transactionHash: Bytes!
}

type Accumulation @entity {
  id: Bytes! # determined by creator
  collateral_accumulation: BigInt! # Total collateral accumulated for the parent entity - summation of collateral_subAccumulation_*
  fee_accumulation: BigInt! # Total fees accumulated for the parent entity - summation of fee_subAccumulation_*
  #
  collateral_subAccumulation_offset: BigInt! # Total Price offset for the parent entity
  collateral_subAccumulation_pnl: BigInt! # Total price based PNL for the parent entity
  collateral_subAccumulation_funding: BigInt! # Total funding accumulated for the parent entity
  collateral_subAccumulation_interest: BigInt! # Total interest accumulated for the parent entity
  collateral_subAccumulation_makerPositionFee: BigInt! # Total maker position fees accumulated for the parent entity (maker position only)
  collateral_subAccumulation_makerExposure: BigInt! # Total maker exposure accumulated for the parent entity (maker position only)
  fee_subAccumulation_settlement: BigInt! # Settlement fee charged for the parent entity
  fee_subAccumulation_trade: BigInt! # Trade fee charged for the parent entity
  fee_subAccumulation_liquidation: BigInt! # Liquidation fee charged for the parent entity
  fee_subAccumulation_additive: BigInt! # Additive (interface) fees for the parent entity
  fee_subAccumulation_triggerOrder: BigInt! # Trigger order fees for the parent entity
  #
  metadata_subtractiveFee: BigInt! # Subtractive fee for the parent entity - included as part of the order's offset and trade fee
}
