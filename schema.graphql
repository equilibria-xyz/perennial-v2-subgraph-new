type Market @entity {
  id: Bytes! # Address
  token: Bytes!
  oracle: Oracle!
  payoff: Bytes
  marketAccounts: [MarketAccount!]! @derivedFrom(field: "market")

  maker: BigInt!
  long: BigInt!
  short: BigInt!

  latestPrice: BigInt!
  latestVersion: BigInt!
  currentVersion: BigInt!
  latestOrderId: BigInt!
  currentOrderId: BigInt!

  accumulators: [MarketAccumulator!]! @derivedFrom(field: "market")
}

type MarketOrder @entity {
  id: Bytes! # markeetAddress:orderId
  version: BigInt!
  maker: BigInt!
  long: BigInt!
  short: BigInt!

  oracleVersion: OracleVersion!
  # TODO: Should this reference the underlying user orders?
}

type Account @entity {
  id: Bytes! # Address
  marketAccounts: [MarketAccount!]! @derivedFrom(field: "account")
}

type MarketAccount @entity {
  id: Bytes! # markeetAddress:accountAddress
  market: Market!
  account: Account!
  positions: [Position!]! @derivedFrom(field: "marketAccount")

  maker: BigInt!
  long: BigInt!
  short: BigInt!

  pendingMaker: BigInt! # v2.0.1 tracking only
  pendingLong: BigInt! # v2.0.1 tracking only
  pendingShort: BigInt! # v2.0.1 tracking only
  makerInvalidation: BigInt! # v2.0.1 tracking only
  longInvalidation: BigInt! # v2.0.1 tracking only
  shortInvalidation: BigInt! # v2.0.1 tracking only
  #
  positionNonce: BigInt!
  latestVersion: BigInt!
  currentVersion: BigInt!
  latestOrderId: BigInt!
  currentOrderId: BigInt!
  collateral: BigInt!
}

type Position @entity {
  id: Bytes! # markeetAddress:accountAddress:positionNonce
  marketAccount: MarketAccount!
  orders: [Order!]! @derivedFrom(field: "position")
  nonce: BigInt!

  maker: BigInt! # Optimistically updated on Fulfillment
  long: BigInt! # Optimistically updated on Fulfillment
  short: BigInt! # Optimistically updated on Fulfillment
  #
  startCollateral: BigInt!
}

type Order @entity {
  id: Bytes! # markeetAddress:accountAddress:orderId
  position: Position!
  orderId: BigInt!
  version: BigInt! # Needed for sorting since we can't sort by child fields
  oracleVersion: OracleVersion!
  startCollateral: BigInt! # Collateral at the time of transaction
  #
  maker: BigInt!
  long: BigInt!
  short: BigInt!
  collateral: BigInt!

  executionPrice: BigInt!

  accumulation_collateral: BigInt!
  accumulation_fees: BigInt!

  collateral_subAccumulation_pnl: BigInt!
  collateral_subAccumulation_funding: BigInt!
  collateral_subAccumulation_interest: BigInt!
  collateral_subAccumulation_makerPositionFee: BigInt!
  collateral_subAccumulation_makerExposure: BigInt!

  transactionHashes: [Bytes!]!
}

type OracleVersion @entity {
  id: Bytes! # oracleAddress:Version
  subOracle: SubOracle!
  marketOrders: [MarketOrder!]! @derivedFrom(field: "oracleVersion")
  orders: [Order!]! @derivedFrom(field: "oracleVersion")

  requested: Boolean!
  timestamp: BigInt!
  valid: Boolean!
  price: BigInt!
}

type Oracle @entity {
  id: Bytes! # Address
  markets: [Market!]! @derivedFrom(field: "oracle")
  subOracle: SubOracle!
}

type SubOracle @entity {
  id: Bytes! # Address
  oracle: Oracle!
  versions: [OracleVersion!]! @derivedFrom(field: "subOracle")
}

# Tracking value to provide pnl breakdowns
type MarketAccumulator @entity(immutable: true) {
  id: Bytes! # market:version
  market: Market! # address
  version: BigInt! # uint256
  pnlMaker: BigInt! # int256
  pnlLong: BigInt! # int256
  pnlShort: BigInt! # int256
  fundingMaker: BigInt! # int256
  fundingLong: BigInt! # int256
  fundingShort: BigInt! # int256
  interestMaker: BigInt! # int256
  interestLong: BigInt! # int256
  interestShort: BigInt! # int256
  positionFeeMaker: BigInt! # uint256
  exposureMaker: BigInt! # uint256
}
